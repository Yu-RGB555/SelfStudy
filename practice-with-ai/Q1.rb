# 「要素の個数を数える（1ずつ足す）」問題

# 問題：
# あるWebサービスのアクセスログが、URLの配列として与えられるとします。
# 各URLが何回アクセスされたかをカウントし、「アクセス数が多い順」に並べ替えて、
# URLをキー、アクセス数を値としたハッシュを返してください。

# 入力例：
url_list = ["/about", "/home", "/contact", "/home", "/home", "/about"]

# 期待する出力：
#{"/home"=>3, "/about"=>2, "/contact"=>1}


# ==============================================
# My解答
# 正解ではあるが、新規のurlが増えた場合の追加対処が困難
# ==============================================
# hash = {}
# hash["/home"] = 0
# hash["/about"] = 0
# hash["/contact"] = 0

# url_list.each do |url|
#   case url
#   when "/home"
#     hash["/home"] = hash["/home"] + 1
#   when "/about"
#     hash["/about"] = hash["/about"] + 1
#   when "/contact"
#     hash["/contact"] = hash["/contact"] + 1
#   else
#     next
#   end
# end

# p hash



# ==============================================
# 模範解答1
# Ruby2.7以降で使用できるtallyメソッドを用いた解答
# ==============================================
# hash = url_list.tally
# #「アクセス数が多い順に並べ替えて」 という条件がある。
# # tally だけだと、出現順にハッシュが作られるため、並び替えの処理を付け加える。
# p hash.sort_by{|url, count| -count }.to_h

# === メモ1 ===
# to_h：対象のオブジェクトをハッシュに変換。
# sort_byは、出力の際に「配列型」にしてしまうので、to_hでハッシュ変換する

# sortは昇順専用
# 降順にする場合は、sort_byと.reverseを組み合わせるか、ソート対象の要素に"-"をつけるかの2通りの方法がある



# ==============================================
# 模範解答2
# 最重要事項：どんなキーが来ても対応できるようにする
# ==============================================

# 1. デフォルト値が0のハッシュを作る
# これにより、存在しないキーを参照したときに nil ではなく 0 が返るようになる
hash = Hash.new(0)

url_list.each do |url|
  # 2. どんな文字列が来ても、そのキーの値を +1 するだけで対応可能
  hash[url] += 1
end

# === 豆知識 ===
# url_list.each { |url| counts[url] += 1 } のようなワンライナーにすることも可能

p hash.sort_by{ |url, count| -count }.to_h
